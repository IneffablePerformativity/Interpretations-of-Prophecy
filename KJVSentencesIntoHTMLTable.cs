// KJVSentencesIntoHTMLTable.cs

// The text manipulation was perfected in this sibling project:
// Well, not quite, I fixed some bugs in this new app...
//
// KVJ_SplitSentences.cs
// in C:\Users\zyzyx\source\repos\KVJ_SplitSentences
// Copied there was also a "KJV1.txt" file for input.
// Newer: KJV from project gutenberg on 2021-08-16 10-0.txt
// Warning: This new file has UTF-8 or some such diffs.


// Now I want to add an HTML TABLE around it:
// Put bible text in left column, like 70 %.
// Put an empty string in rt col, like 30 %.
// Put books and chapter numbers as TH.
// Output the rest to make an HTML page.

/*
 * Web hints for making tables like that:
 * 

How to center-align a table (with CSS):
<html>
<head>
<style>
table, th, td {
  border: 1px solid black;
}
table.center {
  margin-left: auto;
  margin-right: auto;
}
</style>
</head>
<body>

<table class="center"> ...

.....
Basic table:

 <table>
  <tr>
    <th>Month</th>
    <th>Savings</th>
  </tr>
  <tr>
    <td>January</td>
    <td>$100</td>
  </tr>
</table> 


How to create table headers:
<table>
  <tr>
    <th>Name</th>
    <th>Email</th>
    <th>Phone</th>
  </tr>
  <tr>
    <td>John Doe</td>
	...

How to set the width of a table cell (with CSS):
<table style="width:100%">
  <tr>
    <th>Month</th>
    <th>Savings</th>
  </tr>
  <tr>
    <td style="width:70%">January</td>
    <td style="width:30%">$100</td>
  </tr>
</table> 

==========================

So, my HTML PAGE TEMPLATE code outside of all the TR, TH/TD:

<html>
<head>
<style>
table, th, td {
  border: 1px solid black;
}
table.center {
  margin-left: auto;
  margin-right: auto;
}
</style>
</head>
<body>
<table class="center">

<tr>
.... TR... /TR = Rows will be generated by the loops....
</tr>

</table> 
</body>
</html>

=========================

AND, MY PLAN FOR THE ROWS, to be output during loops:

======= HEADERS:

<tr>
<th>
... Here, output each book title. ...
</th>
</tr>

======= DATA:

<tr>
<td style="width:70%">
... Here, output each Sentence. ...
</td>
<td style="width:30%">
</td>
</tr>


=========================


 *
 *
 */




using System;
using System.Collections.Generic;
using System.IO;
using System.Text.RegularExpressions;

namespace KVJ_SplitSentences
{
    class Program
    {
        static string inputPath = @"C:\Users\zyzyx\source\repos\KJVSentencesIntoHTMLTable\KJV from project gutenberg on 2021-08-16 10-0.txt";

        // By this bool I can make you also do what the original app did, make plain text:
        static bool doHtml = true;

        // I found these 66 short names at https://believersportal.com/list-66-books-bible/

        static string[] bookNames = new string[] {
            "", // skip 0; I will index 1 up to also output number books 1-66
            "Genesis",
            "Exodus",
            "Leviticus",
            "Numbers",
            "Deuteronomy",
            "Joshua",
            "Judges",
            "Ruth",
            "1 Samuel",
            "2 Samuel",
            "1 Kings",
            "2 Kings",
            "1 Chronicles",
            "2 Chronicles",
            "Ezra",
            "Nehemiah",
            "Esther",
            "Job",
            "Psalms",
            "Proverbs",
            "Ecclesiastes",
            "Song of Solomon",
            "Isaiah",
            "Jeremiah",
            "Lamentations",
            "Ezekiel",
            "Daniel",
            "Hosea",
            "Joel",
            "Amos",
            "Obadiah",
            "Jonah",
            "Micah",
            "Nahum",
            "Habakkuk",
            "Zephaniah",
            "Haggai",
            "Zechariah",
            "Malachi",
            "Matthew",
            "Mark",
            "Luke",
            "John",
            "Acts",
            "Romans",
            "1 Corinthians",
            "2 Corinthians",
            "Galatians",
            "Ephesians",
            "Philippians",
            "Colossians",
            "1 Thessalonians",
            "2 Thessalonians",
            "1 Timothy",
            "2 Timothy",
            "Titus",
            "Philemon",
            "Hebrews",
            "James",
            "1 Peter",
            "2 Peter",
            "1 John",
            "2 John",
            "3 John",
            "Jude",
            "Revelation",
            };

        // New strings needed to output an HTML page:
        // C# does not support HEREDOC style strings.
        // Use notepad++ to fix Dbl quotes, add \r\n.

        static string htmlPageTop = "<html>\r\n<head>\r\n<style>\r\ntable {\r\n  width:100%;\r\n  margin-top: 80px;\r\n  border: 1px solid black;\r\n  padding: 0;\r\n}\r\nth {\r\n  width:80%;\r\n  border: 1px solid black;\r\n  padding: 2px;\r\n}\r\ntd {\r\n  border: 1px solid black;\r\n  padding: 2px;\r\n}\r\n</style>\r\n</head>\r\n<body>\r\n<h1>\r\nKJV Bible Sentences + Any Interpretations\r\n</h1>\r\n";

        static string htmlPageEnd = "</body>\r\n</html>";

        // Headers, holding book/chap info:

        static string htmlTableTopAndHeaderRowTop = "<table>\r\n<tr>\r\n<th>";

        static string htmlHeaderRowEnd = "</th>\r\n</tr>";

        // Data, holding a Sentence

        static string htmlDataRowTop = "<tr>\r\n<td>";

        static string htmlDataRowEnd = "</td>\r\n<td>\r\n</td>\r\n</tr>";

        static string htmlTableEnd = "</table>";

        static void htmlTest()
        {
            if(doHtml) Console.WriteLine(htmlPageTop);

            // one chapter

            if(doHtml) Console.WriteLine(htmlTableTopAndHeaderRowTop);
            Console.WriteLine("Book/Chapter title");
            if(doHtml) Console.WriteLine(htmlHeaderRowEnd);

            if(doHtml) Console.WriteLine(htmlDataRowTop);
            Console.WriteLine("This is a sentence.");
            if(doHtml) Console.WriteLine(htmlDataRowEnd);
            if(doHtml) Console.WriteLine(htmlDataRowTop);
            Console.WriteLine("Sentence.");
            if(doHtml) Console.WriteLine(htmlDataRowEnd);
            if(doHtml) Console.WriteLine(htmlTableEnd);

            // second chapter

            if(doHtml) Console.WriteLine(htmlTableTopAndHeaderRowTop);
            Console.WriteLine("Second Book/Chapter title");
            if(doHtml) Console.WriteLine(htmlHeaderRowEnd);

            if(doHtml) Console.WriteLine(htmlDataRowTop);
            Console.WriteLine("This is a sentence.");
            if(doHtml) Console.WriteLine(htmlDataRowEnd);
            if(doHtml) Console.WriteLine(htmlDataRowTop);
            Console.WriteLine("Sentence.");
            if(doHtml) Console.WriteLine(htmlDataRowEnd);
            if(doHtml) Console.WriteLine(htmlTableEnd);


            if(doHtml) Console.WriteLine(htmlPageEnd);
        }

        static string currentBookChapterPrefix = "";

        static void Main(string[] args)
        {
            // this is pretty now.
            // Now get back to work.
            // htmlTest();
            // return;

            // Console.WriteLine("Hello World!");
            string rawBody = File.ReadAllText(inputPath);

            // Fix the non-ascii
            char bad = (char)8217;
            rawBody = rawBody.Replace(bad, '\'');

            /* good now...
            // (re-)Study the non-asciis
            int nNonAscii = 0; // 1971!
            // Not bad, just one apostraphe-like char:
            // nNonAscii = 1971
            // (int)c = 8217 = '''

            SortedSet<char> nonAscii = new SortedSet<char>();
            for (int i = 0; i < rawBody.Length; i ++)
            {
                char c = rawBody[i];
                if(c > '~')
                {
                    // non-7 bit USASCII
                    nNonAscii++;
                    nonAscii.Add(c);
                }
            }
            Console.WriteLine("nNonAscii = " + nNonAscii);
            foreach(char c in nonAscii)
            {
                Console.WriteLine("(int)c = " + (int)c + " = '" + c + "'");
            }
            ...*/

            // fix newlines
            Regex crlfs = new Regex("(\r\n|\r|\n)");
            rawBody = crlfs.Replace(rawBody, "\n");

            // the books are separated by 4 blank lines (5 newlines)
            Regex fiveNl = new Regex("\n{5}");
            string[] books = fiveNl.Split(rawBody);
            // Console.WriteLine("books.Length = " + books.Length); // 71, which is 66 books + 5 garbage.

            int nRealBooks = 0;
            // 66. Perfect

            if(doHtml) Console.WriteLine(htmlPageTop);

            // Use this loop using "1:1" to process each book.
            // Each book has some title line(s) prior to "1:1"
            // From "1:1" to the end should be all the verses.

            foreach (string book1 in books)
            {
                string book = book1;
                if (book.Contains("1:1"))
                {
                    // likely a real book
                    nRealBooks++;

                    // This style, #01 = Genesis will allow me to search for '= Book...'

                    currentBookChapterPrefix = "Book #" + nRealBooks.ToString("d2") + " = " + bookNames[nRealBooks];

                    if (nRealBooks == 66)
                    {
                        // During the very last book, #66,
                        // rid trailer text that starts like this:
                        // *** END OF THE PROJECT GUTENBERG EBOOK THE KING JAMES BIBLE ***

                        int rid = book.IndexOf("***");
                        if (rid > 0)
                            book = book.Substring(0, rid);
                    }
                    //skip title, subcontract
                    int skip = book.IndexOf("1:1");
                    processBook(book.Substring(skip));
                }
            }

            if(doHtml) Console.WriteLine(htmlPageEnd);

            // Console.WriteLine("nRealBooks = " + nRealBooks); // 66. Perfect
        }

        static void processBook(string book)
        {
            // this call to here will do 1 of 66 entire books.
            // Caller stripped off Title line(s), up to 1:1.

            // It was quick and easy fun,
            // but how will I now locate
            // where each chapter starts?

            // Before stripping all nums from books,
            // first split into chapters upon "1:1 "
            // No, more like "\\d+:1 " to see all.

            Regex xColonOne = new Regex("\\d+:1 ");
            string[] chapters = xColonOne.Split(book);

            int nChapter = 0;
            foreach (string chapt in chapters)
            {
                // For some reason, tl;dr, I have a null first chapt.
                if (chapt.Length < 100)
                    continue; // quick fix I hope

                string chapter = chapt;
                // Revise rest of code below as 'book' -> 'chapter':

                // Make this chapter title part of the output:
                nChapter++;

                if(doHtml) Console.WriteLine(htmlTableTopAndHeaderRowTop);
                Console.WriteLine("\r\n" + currentBookChapterPrefix + ", Chapter " + nChapter + "\r\n");
                if(doHtml) Console.WriteLine(htmlHeaderRowEnd);

                // Prior app showed sentences cross verses.
                // Therefore, rid all the verse numbers.
                // Also rid all the newlines to spaces.
                Regex nums = new Regex("\\d+:\\d+");
                chapter = nums.Replace(chapter, "");
                chapter = chapter.Replace("\n", " ");
                // Fix any excess spaces
                Regex xssp = new Regex(" +");
                chapter = xssp.Replace(chapter, " ").Trim();

                // show me some. Great... ( on books ).
                // Console.WriteLine(chapter.Substring(0, 250));
                // Console.WriteLine("=========");

                // The text looks great.
                // Now delimit sentences.

                // This will match one sentence at a time, from start.
                Regex firstSentence = new Regex(@"^([^:.?!]+[:.?!]\)?)");

                // I need to be a tad bit more selective: The COLON should
                // end a sentence if at end, or if followed by a space and
                // an uppercase. I can use this regex rule from the web:
                // 
                // If you want to stop before that word, you need to look ahead:
                // .*(?= after) will match any text that is followed by after.

                // Or I could just hold it to become a prefix for the next loop.
                // I have seen sentences that need to join prefix multiple times.

                string anyPrefix = "";

                while (chapter != "")
                {
                    Match m = firstSentence.Match(chapter);
                    if (m.Success)
                    {
                        // For a nice first cut, this will be the main output of program:
                        // That looks beautiful.
                        // But I would like to re-add chapter Names, and maybe with chapter.
                        // That will be inserted elsewhere.

                        string SentenceCandidate = m.Groups[0].Value;
                        chapter = firstSentence.Replace(chapter, "").Trim();

                        // special test if it ends with a colon:
                        if (SentenceCandidate.EndsWith(":"))
                        {
                            // if it is followed by a-z (not at chapter[0]), save as a prefix.
                            // ascii a-z have 0x20 bit, A-Z do not:
                            if (chapter.Length > 0 && (chapter[0] & 0x20) != 0)
                            {
                                anyPrefix = anyPrefix + SentenceCandidate + " ";
                            }
                            else
                            {
                                // else, it is followed by A-Z or end of string, output it now.

                                if(doHtml) Console.WriteLine(htmlDataRowTop);
                                Console.WriteLine(anyPrefix + SentenceCandidate);
                                if(doHtml) Console.WriteLine(htmlDataRowEnd);
                                anyPrefix = "";
                            }
                        }
                        else
                        {
                            // output it now:
                            if(doHtml) Console.WriteLine(htmlDataRowTop);
                            Console.WriteLine(anyPrefix + SentenceCandidate);
                            if(doHtml) Console.WriteLine(htmlDataRowEnd);
                            anyPrefix = "";
                        }
                    }
                    else
                    {
                        // I should find no leftover texts.
                        // Console.WriteLine(chapter);
                        // I only saw one output, "***", which starts the PG trailer after chapter 66.
                        // Fixed above.
                        break;
                    }
                }
                if(doHtml) Console.WriteLine(htmlTableEnd);
            }
        }
    }
}
